"""
 住专转 专拽注 砖专转
Background Removal - Conservative Algorithm
"""

from PIL import Image, ImageFilter
from collections import deque

def remove_background_conservative(img: Image) -> Image:
    """
    住专 专拽注 /专 爪专 砖专转
    砖专 注 驻拽住 驻 (拽住, ...)
    
    Args:
        img: 转转 PIL
        
    Returns:
        转 注 专拽注 砖拽祝 (RGBA)
    """
    # 专 -RGBA
    if img.mode != 'RGBA':
        img = img.convert('RGBA')
    
    width, height = img.size
    pixels = img.load()
    
    # 转 爪注 拽爪转 ( 20 驻拽住)
    edge_colors = []
    
    # 拽爪 注
    for x in range(0, width, max(1, width // 20)):
        if 0 <= x < width:
            edge_colors.append(pixels[x, 0][:3])
    
    # 拽爪 转转
    for x in range(0, width, max(1, width // 20)):
        if 0 <= x < width:
            edge_colors.append(pixels[x, height - 1][:3])
    
    # 拽爪 砖
    for y in range(0, height, max(1, height // 20)):
        if 0 <= y < height:
            edge_colors.append(pixels[0, y][:3])
    
    # 拽爪 
    for y in range(0, height, max(1, height // 20)):
        if 0 <= y < height:
            edge_colors.append(pixels[width - 1, y][:3])
    
    # 砖 爪注 专拽注 爪注
    if not edge_colors:
        return img
    
    avg_r = sum(c[0] for c in edge_colors) // len(edge_colors)
    avg_g = sum(c[1] for c in edge_colors) // len(edge_colors)
    avg_b = sum(c[2] for c in edge_colors) // len(edge_colors)
    bg_color = (avg_r, avg_g, avg_b)
    
    # 住祝 驻转 专住
    threshold = 45
    
    # Flood fill 拽爪转
    to_remove = set()
    visited = set()
    queue = deque()
    
    # 转  驻转 转
    corners = [(0, 0), (width - 1, 0), (0, height - 1), (width - 1, height - 1)]
    for x, y in corners:
        if (x, y) not in visited:
            r, g, b = pixels[x, y][:3]
            if abs(r - bg_color[0]) + abs(g - bg_color[1]) + abs(b - bg_color[2]) < threshold * 3:
                queue.append((x, y))
                visited.add((x, y))
    
    # Flood fill
    while queue:
        x, y = queue.popleft()
        to_remove.add((x, y))
        
        # 拽 砖
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:
                visited.add((nx, ny))
                r, g, b = pixels[nx, ny][:3]
                
                if abs(r - bg_color[0]) + abs(g - bg_color[1]) + abs(b - bg_color[2]) < threshold * 3:
                    queue.append((nx, ny))
    
    # 住专 专拽注
    for x, y in to_remove:
        pixels[x, y] = (255, 255, 255, 0)
    
    # 砖砖 拽  砖 拽爪转
    alpha = img.split()[3]
    alpha = alpha.filter(ImageFilter.GaussianBlur(0.5))
    img.putalpha(alpha)
    
    return img


def crop_to_content(img: Image) -> Image:
    """
    转 转 驻 转 ( 专拽注 砖拽祝)
    
    Args:
        img: 转转 RGBA
        
    Returns:
        转 转
    """
    if img.mode != 'RGBA':
        img = img.convert('RGBA')
    
    alpha = img.getchannel('A')
    bbox = alpha.getbbox()
    
    if bbox:
        return img.crop(bbox)
    else:
        return img
